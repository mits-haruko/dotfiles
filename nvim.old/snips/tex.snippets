global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'

def comment(): 
	return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
	[x,y] = vim.eval("vimtex#env#is_inside('" + name + "')") 
	return x != '0' and y != '0'

endglobal

snippet bg "begin{} / end{}" bA
\\begin{$1}
	$0
\\end{$1}
endsnippet

### Text snippets ### 

# \{
context "math()"
snippet lb "brackets" i
\\{$1\\}$0
endsnippet

#rightarrow
context "math()"
snippet rw "\rightarrow" iA
\to
endsnippet

#mathbb
context "math()"
snippet mbb "\mathbb" iA
\mathbb{$1}$0
endsnippet

#fancy math2
context "math()"
snippet msf "\mathscr" iA
\mathscr{$1}$0
endsnippet

#bold
snippet tbf "\textbf" iA
\textbf{$1}$0
endsnippet

#circ
context "math()"
snippet cc "circ" iA
\circ
endsnippet

#lvert
context "math()"
snippet lv "lvert" iA
\lvert_
endsnippet

#fiber bundle
context "math()"
snippet fib "fiber" iA
\pi:\mathscr{E}\to\mathscr{M}
endsnippet

#fiber bundle 2
snippet fbn "fiber2" iA
\pi':\mathscr{F}\to\mathscr{N}
endsnippet

# Jet bundle
snippet \jb "jetbundle" iA
J^r(\mathscr{$1}\to\mathscr{$2})$0
endsnippet

# Jet Bundle of Sections
snippet \js "jetsections" iA
J^r(\mathscr{$1}\to\mathscr{$2})$0
endsnippet

# Module of sections
context "math()"
snippet sec "bundle-sections" iA
\Gamma(\mathscr{$1}\to\mathscr{$2})$0
endsnippet

# Module of sections simple
context "math()"
snippet sc "bundle-sections" iA
\Gamma($1)$0
endsnippet

# Smooth mappings
context "math()"
snippet cf "smooth-mappings" iA
\mathscr{C}^\infty(\mathscr{$1},\mathscr{$2})$0
endsnippet

# Smooth functions
context "math()"
snippet sfunc "smooth-functions" iA
\mathscr{C}^\infty(\mathscr{$1},\mathbb{$2})$0
endsnippet

#C^infty(M)-linear
snippet cinf "linear" iA
$\mathscr{C}^\infty(\mathscr{$1})$-linear$0
endsnippet

# Equivalence relation
context "math()"
snippet rel "equivalence"
\stackrel{\mathrm{$1}}{\tilde}$0
endsnippet

# Compactly supported sections
snippet csup "compact support" iA
\Gamma_c(\mathscr{$1})$0
endsnippet

#D_K(U)
context "math()"
snippet DK "test functions" iA
\mathscr{D}_{$1}(\mathscr{$2}\to\mathscr{$3})$0
endsnippet

# D(U)
context "math()"
snippet tst "test functions" i
\mathscr{D}(\mathscr{$1}\to\mathscr{$2})$0
endsnippet

# distribution space
context "math()"
snippet dist "distribution space" iA
\mathscr{D}'($1)$0
endsnippet

# cotangent bundle
context "math()"
snippet ctg "cotangent bundle" iA
T^\ast\!\mathscr{$1}$0
endsnippet

# densities
context "math()"
snippet dens "densities" iA
|\Lambda|^{$1}($2)$0
endsnippet

# chart
context "math()"
snippet cx "chart" iA
(U,\x)
endsnippet

# chart 
context "math()"
snippet cy "chart" iA
(V,\y)
endsnippet

# atlas
context "math()"
snippet ux "atlas" iA
\\{(U_i,\x_i)\\}_{i\in I}
endsnippet

# atlas
context "math()"
snippet vy "atlas" iA
\\{(V_j,\y_j)\\}_{j\in J}
endsnippet

# vector bundle chart
context "math()"
snippet vc "chart" iA
(U,\psi)
endsnippet

# vector bundle atlas
context "math()"
snippet vb "vb atlas" iA
\\{(U_i,\psi_i)\\}_{i\in I}
endsnippet

context "math()"
snippet md "mod alpha" iA
|\alpha|\leq $1
endsnippet

context "math()"
snippet salf "sum alpha" iA
sum_{|$1|\leq $2}$0
endsnippet

### ENVIRONMENTS ###
snippet eq "equation" i
\begin{equation}\label{$2}
$1
\end{equation}
$0
endsnippet

snippet enum "Enumerate" bA
\begin{enumerate}
	\item $0
\end{enumerate}
endsnippet

snippet item "Itemize" bA
\begin{itemize}
	\item $0
\end{itemize}
endsnippet

snippet mk "Math" wA
$${1}$`!p
#if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
#	snip.rv = ' '
#else:
#	snip.rv = ''
`$2
endsnippet

snippet dm "Math" wA
\[
${1:${VISUAL}} 
\] $0
endsnippet

snippet ali "Align" bA
\begin{aligned}
	${1:${VISUAL}}
\end{aligned}
endsnippet


context "math()"
snippet // "Fraction" iA
\\frac{$1}{$2}$0
endsnippet

snippet / "Fraction" i
\\frac{${VISUAL}}{$1}$0
endsnippet

### OPERATORS ###

snippet => "implies" Ai
\implies
endsnippet

snippet =< "implied by" Ai
\impliedby
endsnippet

context "math()"
snippet iff "iff" 
\iff
endsnippet

context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

priority 10000
snippet 'sympy(.*)sympy' "sympy" wr
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1).replace('\\', '').replace('^', '**').replace('{', '(').replace('}', ')') + ')')
`
endsnippet

priority 1000
snippet math "mathematicablock" w
math $1 math$0
endsnippet

priority 10000
snippet 'math(.*)math' "math" wr
`!p
import subprocess
code = match.group(1)
code = 'ToString[' + code + ', TeXForm]'
snip.rv = subprocess.check_output(['wolframscript', '-code', code])
`
endsnippet

snippet == "equals" iA
&= $1 \\\\
endsnippet

snippet neq "equals" iA
\neq 
endsnippet

snippet pmat "pmat" iA
\begin{pmatrix} $1 \end{pmatrix} $0
endsnippet

snippet bmat "bmat" iA
\begin{bmatrix} $1 \end{bmatrix} $0
endsnippet

context "math()"
snippet lang "< >" iA
\langle $1,$2 \rangle$0
endsnippet

context "math()"
snippet () "left( right)" iA
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right| $0
endsnippet

snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right] $0
endsnippet

snippet lra "leftangle rightangle" iA
\left<${1:${VISUAL}} \right>$0
endsnippet

context "math()"
snippet conj "conjugate" iA
\overline{$1}$0
endsnippet

context "math()"
snippet sind "sum" w
\sum_{n=${1:1}}^{${2:\infty}} ${3:a_n z^n}
endsnippet

context "math()"
snippet taylor "taylor" w
\sum_{${1:k}=${2:0}}^{${3:\infty}} ${4:c_$1} (x-a)^$1 $0
endsnippet

context "math()"
snippet lim "limit" w
\lim_{${1:n} \to ${2:\infty}} 
endsnippet

context "math()"
snippet limsup "limsup" w
\limsup_{${1:n} \to ${2:\infty}} 
endsnippet

context "math()"
snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet

context "math()"
snippet pd "d/dx" w
\partial^{$1}$0
endsnippet

context "math()"
snippet pa "partial alpha" i
\partial
endsnippet

context "math()"
snippet sq "\sqrt{}" iA
\sqrt{${1:${VISUAL}}} $0
endsnippet

context "math()"
snippet sr "^2" iA
^2
endsnippet

context "math()"
snippet cb "^3" iA
^3
endsnippet

context "math()"
snippet td "to the ... power" iA
^{$1}$0
endsnippet

context "math()"
snippet rd "to the ... power" iA
^{($1)}$0
endsnippet

snippet __ "subscript" iA
_{$1}$0
endsnippet

snippet ooo "\infty" iA
\infty
endsnippet

snippet rij "mrij" i
(${1:x}_${2:n})_{${3:$2}\\in${4:\\N}}$0
endsnippet

snippet <= "leq" iA
\le 
endsnippet

snippet >= "geq" iA
\ge 
endsnippet

context "math()"
snippet AA "forall" iA
\forall 
endsnippet

context "math()"
snippet xnn "xn" iA
x_{n}
endsnippet

context "math()"
snippet ynn "yn" iA
y_{n}
endsnippet


context "math()"
snippet xii "xi" iA
x_i
endsnippet

context "math()"
snippet yii "yi" iA
y_i
endsnippet

context "math()"
snippet xjj "xj" iA
x_j
endsnippet

context "math()"
snippet yjj "yj" iA
y_j
endsnippet

context "math()"
snippet xp1 "x" iA
x_{n+1}
endsnippet

context "math()"
snippet xmm "x" iA
x_{m}
endsnippet

### Cut from here

context "math()"
snippet nab "nabla" iA
\nabla
endsnippet

context "math()"
snippet xx "cross" iA
\times 
endsnippet

priority 100
snippet ** "cdot" iA
\cdot 
endsnippet

context "math()"
snippet norm "norm" iA
\|$1\|$0
endsnippet

priority 100
context "math()"
snippet '(?<!\\)(sin|cos|arccot|cot|csc|ln|log|exp|star|perp)' "ln" rwA
\\`!p snip.rv = match.group(1)`
endsnippet

priority 300
context "math()"
snippet dint "integral" wA
\int_{${1:-\infty}}^{${2:\infty}} ${3:${VISUAL}} $0
endsnippet

priority 200
context "math()"
snippet '(?<!\\)(arcsin|arccos|arctan|arccot|arccsc|arcsec|pi|zeta|int)' "ln" rwA
\\`!p snip.rv = match.group(1)`
endsnippet

priority 200
context "math()"
snippet <-> "leftrightarrow" iA
\leftrightarrow
endsnippet

context "math()"
snippet !> "mapsto" iA
\mapsto 
endsnippet

context "math()"
snippet invs "inverse" iA
^{-1}
endsnippet

context "math()"
snippet compl "complement" iA
^{c}
endsnippet

context "math()"
snippet \\\ "setminus" iA
\setminus
endsnippet

snippet >> ">>" iA
\gg
endsnippet

snippet << "<<" iA
\ll
endsnippet


snippet ~~ "~" iA
\sim 
endsnippet

context "math()"
snippet set "set" wA
\\{$1\\}$0
endsnippet

context "math()"
snippet fm "family" wA
\\{$1\\}_{$2}$0
endsnippet

context "math()"
snippet sb "subset" i
\subseteq 
endsnippet

context "math()"
snippet notin "not in " iA
\not\in 
endsnippet

context "math()"
snippet inn "in " iA
\in 
endsnippet

snippet NN "n" iA
\N
endsnippet

snippet Nn "cap" iA
\cap 
endsnippet

snippet UU "cup" iA
\cup 
endsnippet

snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

snippet vnt "emptyset" iA
\varnothing
endsnippet

snippet mbb "real" iA
\mathbb{${1:}}$0
endsnippet

snippet <! "normal" iA
\triangleleft 
endsnippet

snippet <> "hokje" iA
\diamond 
endsnippet


context "math()"
snippet '(?<!i)sts' "text subscript" irA
_\text{$1} $0
endsnippet

context "math()"
snippet case "cases" wA
\begin{cases}
	$1
\end{cases}
endsnippet

snippet SI "SI" iA
\SI{$1}{$2}
endsnippet

snippet bigfun "Big function" iA
\begin{align*}
	$1: $2 &\longrightarrow $3 \\\\
	$4 &\longmapsto $1($4) = $0
.\end{align*}
endsnippet

snippet cvec "column vector" iA
\begin{pmatrix} ${1:x}_${2:1}\\\\ \vdots\\\\ $1_${2:n} \end{pmatrix}
endsnippet

priority 10
context "math()"
snippet "bar" "bar" riA
\overline{$1}$0
endsnippet

priority 100
context "math()"
snippet "([a-zA-Z])bar" "bar" riA
\overline{`!p snip.rv=match.group(1)`}
endsnippet

priority 10
context "math()"
snippet "hat" "hat" riA
\hat{$1}$0
endsnippet

priority 100
context "math()"
snippet "([a-zA-Z])hat" "hat" riA
\hat{`!p snip.rv=match.group(1)`}
endsnippet

snippet letw "let omega" iA
Let $\Omega \subset \C$ be open.
endsnippet

# vim:ft=snippets
